<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>菜刚RyuGou的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="菜刚RyuGou的博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="菜刚RyuGou的博客">
<meta property="og:locale">
<meta property="article:author" content="菜刚">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="菜刚RyuGou的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">菜刚RyuGou的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-mysql-lock" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/23/mysql-lock/" class="article-date">
  <time datetime="2019-02-23T07:19:39.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/23/mysql-lock/">秒懂InnoDB的锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天我们来聊聊MySQL中InnoDB存储引擎的锁。</p>
<p>锁是数据库系统系统区别于文件系统的一个关键特性。</p>
<h1 id="lock和-latch"><a href="#lock和-latch" class="headerlink" title="lock和 latch"></a>lock和 latch</h1><h2 id="latch"><a href="#latch" class="headerlink" title="latch"></a>latch</h2><p><code>latch</code>在MySQL中是用来保证并发多线程操作操作临界资源的<code>锁</code>，锁定的对象线程，是和咱们使用的Java等传统语言中的锁意义相近，而且没有死锁检测的机制。</p>
<h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p><code>lock</code>是MySQL中在事务中使用的<code>锁</code>，锁定的对象是事务，来锁定数据库中表、页、行；通常只有在事务commit或者rollback后进行释放。lock是有死锁机制的，当出现死锁时，lock有死锁机制来解决死锁问题：超时时间(参数<code>innodb_lock_wait_timeout</code>)、<code>wait-for graph</code>。</p>
<p>我们通常讲的MySQL的“锁”，一般就是说的lock。</p>
<p>以下就是InnoDB中“锁”的大分类：</p>
<p><img src="/img/mysql_lock/lock_latch.png"></p>
<h1 id="lock的种类"><a href="#lock的种类" class="headerlink" title="lock的种类"></a>lock的种类</h1><p>MySQL Lock大体上可以分为：表锁、行锁、意向锁三种。</p>
<p><img src="/img/mysql_lock/Locks.png"></p>
<h2 id="共享-排他锁"><a href="#共享-排他锁" class="headerlink" title="共享&#x2F;排他锁"></a>共享&#x2F;排他锁</h2><p>行锁分为：<code>S Lock</code>和<code>X Lock</code>。<code>S Lock</code> ：读锁；<code>X Lock</code>：写锁。<br>两锁之间的兼容性如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">       X         S</span><br><span class="line">X     不兼容     不兼容</span><br><span class="line">S     不兼容     兼容</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单总结为：<code>读锁可以读，读锁不可写；写锁不可读也tm不可写。</code></p>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>InnoDB支持多粒度的锁，即：允许表锁和行锁同时存在。<br>但是，假如表锁覆盖了行锁的数据，所以表锁和行锁也会产生冲突。如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trx1 BEGI</span><br><span class="line"></span><br><span class="line">trx1 给 T1 加X锁修改数据。</span><br><span class="line"></span><br><span class="line">trx2 BEGIN</span><br><span class="line"></span><br><span class="line">trx2 给 T1 加表锁修改表结构</span><br></pre></td></tr></table></figure>
<p>这样，表锁和行锁之间就产生了冲突，为了解决这种表锁和行锁共存的问题，就产生了<code>意向锁</code>这个东西。<br>意向锁：从字面意思也很好理解，就是提前表明一个“意向”。</p>
<p>意向锁分为：</p>
<ul>
<li><code>意向共享锁</code>。它预示着，事务正在或者有意向对表中的”某些行”加S锁。<code>select xxxx lock in share mode</code>，要设置<code>IS</code>锁。</li>
<li><code>意向排他锁</code>。它预示着，事务正在或者有意向表中的“某些行”加X锁。<code>select xxx for update</code>，要设置<code>IX</code>锁。</li>
</ul>
<p>但意向锁仅仅是表明意向，它其实非常弱，意向锁之间可以相互并行，并不是排斥的：<br>意向锁之间的兼容性问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      IS     IX</span><br><span class="line"></span><br><span class="line">IS   兼容    兼容</span><br><span class="line"></span><br><span class="line">IX   兼容    兼容 </span><br></pre></td></tr></table></figure>

<p>但是，意向锁可以和表锁互斥。(注意：文中 S 和 X均为表锁)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        S                X</span><br><span class="line"></span><br><span class="line">IS     兼容           互斥不兼容</span><br><span class="line"></span><br><span class="line">IX    互斥不兼容        互斥不兼容</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>于是，上述现象就变为了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trx1 BEGIN</span><br><span class="line"></span><br><span class="line">trx1 给 T1 先加IX ，然后在某一行记录加X锁。</span><br><span class="line"></span><br><span class="line">trx2 BEGIN</span><br><span class="line"></span><br><span class="line">trx2 给 T1 加表锁X（事务被阻塞，等待加锁成功)</span><br><span class="line"></span><br><span class="line">trx2 修改表结构</span><br></pre></td></tr></table></figure>

<p>也许有人会问：“意向锁存在的意义是什么呢？没有意向锁，行锁和表锁照样可以共存啊？”<br>试问如何共存？<br>“查看表中某一行存在X锁”<br>“如何查看呢？”<br>唯有全表扫描…<br>意向锁的存在就是解决了“全表扫描”的性能问题，所以，意向锁一定是“表级”锁，告诉整张表XXX行存在X锁。此时假如进行表操作就会被阻塞。</p>
<h2 id="主键自增锁"><a href="#主键自增锁" class="headerlink" title="主键自增锁"></a>主键自增锁</h2><p>自增锁(<code>auto-inc Locks</code>)是一种特殊的表级锁，专门针对事务插入<code>AUTO_INCREMENT</code>类型的列，往往就是主键列。可以保证主键的值自增是“原子操作”，不会出现一致性、唯一性问题。</p>
<h1 id="行锁的具体分类"><a href="#行锁的具体分类" class="headerlink" title="行锁的具体分类"></a>行锁的具体分类</h1><p><img src="/img/mysql_lock/arithmetic.png"></p>
<p>InnoDB存储引擎有以上3种行锁算法。以上3种，都是实现在索引上的。</p>
<h2 id="记录锁-Record-Lock"><a href="#记录锁-Record-Lock" class="headerlink" title="记录锁(Record Lock)"></a>记录锁(Record Lock)</h2><p>记录锁(Record Lock)总是会去锁住索引记录。<br>假如没有任何一个索引，那么InnoDB会锁住隐形创建的那个主键。</p>
<p>注意：这里锁的是索引，不一定只是主键索引哦，还可能是二级普通索引。</p>
<h2 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁(Gap Lock)"></a>间隙锁(Gap Lock)</h2><p>顾名思义，它会封锁索引记录中的“缝隙”，让制其他事务在“缝隙”中插入数据。<br>它锁定的是一个不包含索引本身的范围。</p>
<p>例如以下索引数据：<br><img src="/img/mysql_lock/gap_lock.png"></p>
<p><code>间隙锁(Gap Lock)</code>可以锁的将是以下范围</p>
<p><img src="/img/mysql_lock/gap_lock_1.png"></p>
<p>具体的范围还要根据查询条件不同而定。<br>间隙锁开启的事务隔离级别是 <code>Repeatable Read</code>，如果把数据库事务级别降为<code>Read Committed</code>(默认是 <code>Repeatable Read</code>)，间隙锁则会自动失效。</p>
<h2 id="临键锁-Next-Key-Lock"><a href="#临键锁-Next-Key-Lock" class="headerlink" title="临键锁(Next-Key Lock)"></a>临键锁(Next-Key Lock)</h2><p><code>Next-Key Lock</code>可以说是记录锁(<code>Record Lock</code>)和间隙锁（<code>Gap Lock</code>）的组合，既封锁了”缝隙”，又封锁了索引本身。</p>
<p>还是上面的索引数据：<br><img src="/img/mysql_lock/gap_lock.png"></p>
<p><code>临键锁(Next-Key Lock)</code>锁住的范围将是:</p>
<p><img src="/img/mysql_lock/gap_lock_2.png"></p>
<p><code>Next-key Lock</code>在索引具有唯一性的时候，例如主键索引的数据，将会降级为<code>记录锁(Read Lock)</code>，以增加并发性。<br>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        T1                                     T2</span><br><span class="line">        BEGIN;                   |            </span><br><span class="line">   select * From T               |           </span><br><span class="line">   where id = 5 for update       |</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">                                 |            BEGIN; </span><br><span class="line">                                 |          Insert into t (4, xx);</span><br><span class="line">---------------------------------------------------------------              </span><br><span class="line">                                 |          COMMIT</span><br><span class="line">                                 |             </span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">     COMMIT                      |                            </span><br><span class="line">                                 |</span><br><span class="line">                                 |</span><br><span class="line">-----------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>以上情况，就会把<code>Next-key Lock</code>降级为<code>记录锁(Read Lock)</code></p>
<h1 id="再谈不可重复读-No-Reaptable-Read-和幻读-Phantom-Problem"><a href="#再谈不可重复读-No-Reaptable-Read-和幻读-Phantom-Problem" class="headerlink" title="再谈不可重复读(No Reaptable Read)和幻读(Phantom Problem)"></a>再谈不可重复读(<code>No Reaptable Read</code>)和幻读(<code>Phantom Problem</code>)</h1><p>有些很权威的书中认为这俩是同一个概念，例如:&lt;&lt;MySQL技术内幕 InnoDB存储引擎&gt;&gt;。<br>但是就目前网络上的众多总结和个人看法，认为区别如下：</p>
<p><code>不可重复读</code>：修改。在同一个事务中，主要是说多次读取一条记录, 发现该记录中某些列值被修改过。<br><code>幻读</code>:增加或者删除。在同一个事务中，同一条完全相同的查询语句返回的结果集行数不同。</p>
<p>参考：<a href="https://stackoverflow.com/questions/11043712/what-is-the-difference-between-non-repeatable-read-and-phantom-read">https://stackoverflow.com/questions/11043712/what-is-the-difference-between-non-repeatable-read-and-phantom-read</a></p>
<p>认真的说，<code>多版本并发控制 MVCC</code>（读）和 <code>临键锁 Next-Key Lock</code>（写）共同解决了<code>幻读</code>问题。</p>
<p>关于MVCC的原理，就是每份数据会有快照，事务中读取数据(简单的<code>select xxx from</code>，<code>select xx from xx for update</code>或者<code>select xx from xxx in share mode</code>不行)的时候，如果数据被锁住了，就读以前留下的快照数据。在此不过多赘述了。</p>
<p>以下为多版本并发控制原理图<br><img src="/img/mysql_lock/mvcc.png"></p>
<p><code>MVCC</code>只在<code>Read Committed</code>和<code>Repeatable Read</code>下会开启。但是在这两种隔离级别下对于快照指定的数据定义不同。</p>
<p>在<code>Read Committed</code>下，<code>MVCC</code>读取的是被锁定数据的最新的一份数据。<br>在<code>Repeatable Read</code>下，<code>MVCC</code>读取的是事务刚开始时候的数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/23/mysql-lock/" data-id="clzo46bto001wvajh6cc99mf6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-performance-optimize" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/16/mysql-performance-optimize/" class="article-date">
  <time datetime="2019-02-16T05:06:43.000Z" itemprop="datePublished">2019-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/16/mysql-performance-optimize/">MySQL的SQL性能优化总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>很多时候，我们的程序出现的“性能问题”，其实是我们自己写的那”坨”代码的问题，是自己Coding的问题，是Mysql的DML语句使用的问题。<br>以下是我总结的关于MySQL DML语句的使用中需要注意的点。</p>
<h2 id="对于select-要时刻保持谨慎的态度"><a href="#对于select-要时刻保持谨慎的态度" class="headerlink" title="对于select *要时刻保持谨慎的态度"></a>对于<code>select *</code>要时刻保持谨慎的态度</h2><p>绝大多数情况，是不需要<code>select * </code>的。一旦使用了这种语句，便会让优化器无法完成索引覆盖扫描这类优化，而且还会增加额外的I&#x2F;O、内存和CPU的消耗。<br>当然，使用<code>select *</code>也并不是全是坏处，合理的使用<code>select * </code>可以简化开发，提高相同代码的复用性。</p>
<h2 id="是否扫描的太多额外的记录"><a href="#是否扫描的太多额外的记录" class="headerlink" title="是否扫描的太多额外的记录"></a>是否扫描的太多额外的记录</h2><p>有时候会发现某些查询可能需要读取几千行数据，但是仅返回几条或者很少的结果，可以使用以下方式去优化：</p>
<ul>
<li>看看能否改表结构。例如使用汇总表</li>
<li>看看获取数据结果的方式是否最优，获取路劲是否已经是最短。</li>
<li>使用覆盖索引，把所有需要的列都放到索引中，以减少返回表中对应行中取数据的步骤。</li>
</ul>
<h2 id="切分某些SQL语句"><a href="#切分某些SQL语句" class="headerlink" title="切分某些SQL语句"></a>切分某些SQL语句</h2><p>传统的互联网系统中，强调网络连接尽量少，数据层尽可能在一次连接中完成尽可能多的工作，防止建立多次链接，但是这种想法对于MySQL并不适用，MySQL从设计上让连接和断开都很轻量，在一般服务器上可以支持每秒超过10万的查询。</p>
<p>所以对于有些场景下，可以将一个大的查询“分而治之”，切分成小查询，然后再组合起来。例如以下情况：</p>
<ul>
<li>对于全量数据查询变成分页。假如一张表中有数千万条数据，一次select all，肯定是不行的。可以换成一次取一部分，把一次的压力分摊。</li>
<li>删除大量旧数据的时候，不要一个大的语句一次性清完，推荐<code>一次删一万条</code>。如果用一个大的语句一次性完成的话，可能需要一次锁住大量数据，占满大量日志事务，让Mysql停在那儿了，为避免这种情况发生，最好一次性删除一万条左右的数据，然后每次删完暂停一会儿再操作，将服务器上的一次性压力分散。</li>
</ul>
<p>注意：虽然Mysql建立连接十分轻量，但是这不意味着可以逐条循环中查询然后再拼接，这样效率依然是非常慢，而且通常是工作中sql优化的点。</p>
<h2 id="慎用join操作"><a href="#慎用join操作" class="headerlink" title="慎用join操作"></a>慎用<code>join</code>操作</h2><p>这算是一条禁忌吧，很多公司的互联网产品都杜绝join操作，换成先从一张表中先取出数据id，再从另外一张表中使用<code>where in</code>查询的两次单表查询操作。主要是以下几点原因：</p>
<ul>
<li>让应用的缓存(redis、memcache等)更高效。例如在第一张表中查询出部分id了，如果命中了缓存，就可以省去一条where in语句了。</li>
<li>更容易应对业务的发展，方便对数据库进行拆分，更容易做到高性能和高扩展。</li>
<li>对where in中的id进行升序排序后，查询效率比join的随机关联更高效</li>
<li>减少多余的查询。在应用层中两次查询，意味着对某条记录应用只需要查询一次，而使用join可能需要重复的扫描访问一部分数据。</li>
<li>单张表查询可以减少锁的竞争。</li>
</ul>
<p>假如非用不可，可以采用以下方式来优化：</p>
<ul>
<li>确保<code>ON</code>或者<code>using</code>子句中的列上有索引</li>
<li>确保任何的<code>group by</code>和<code>order by</code>中的表达式只涉及到一个表中的列。</li>
</ul>
<h2 id="在性能要求比较高的场景中，杜绝查询中使用临时表"><a href="#在性能要求比较高的场景中，杜绝查询中使用临时表" class="headerlink" title="在性能要求比较高的场景中，杜绝查询中使用临时表"></a>在性能要求比较高的场景中，杜绝查询中使用<code>临时表</code></h2><p>MySQL的临时表示没有任何索引的，使用临时表一般都意味着性能比较低,因此在对性能要求比较高的场景中，最好不要使用带有临时表的操作：</p>
<ul>
<li>未带索引的字段上的<code>group by</code>操作。</li>
<li><code>UNION</code>查询。</li>
<li>查询语句中的子查询。</li>
<li>部分<code>order by </code>操作，例如<code>distinct</code>函数和<code>order by</code>一起使用且<code>distinct</code>和<code>order by</code>同一个字段。再例如某些情况下<code>group by</code>和<code>order by</code>字段不同。</li>
</ul>
<p>具体是否用到临时表，可以通过<code>explain</code>来查看，查看<code>Extra</code>列的结果，如果出现<code>Using temporary</code>则需要注意。</p>
<h2 id="count-函数优化"><a href="#count-函数优化" class="headerlink" title="count()函数优化"></a><code>count()</code>函数优化</h2><p><code>count()</code>函数有一点需要特别注意：它是不统计值为NULL的字段的！所以：不能指定查询结果的某一列，来统计结果行数。即<code>count(xx column)</code> 不太好。</p>
<p>如果想要统计结果集，就使用<code>count(*)</code>，性能也会很好。</p>
<h2 id="尽量不使用子查询"><a href="#尽量不使用子查询" class="headerlink" title="尽量不使用子查询"></a>尽量不使用子查询</h2><p>尽量别使用子查询，尽可能的使用关联来代替</p>
<h2 id="优化分页limit"><a href="#优化分页limit" class="headerlink" title="优化分页limit"></a>优化分页<code>limit</code></h2><p>通常我们在分页的时候，通常使用的是<code>limit 50, 10</code>这种语句。数据少还不错，但是当数据偏移量非常大的时候，性能就会出现问题，例如<code>select xx,xxx from test_table limit 100000020, 20</code>。扫描了100000020条数据，才返回20条数据。这个时候我们可以用一下两种方式来优化：</p>
<h3 id="利用between-and-和主键索引"><a href="#利用between-and-和主键索引" class="headerlink" title="利用between and 和主键索引"></a>利用<code>between and </code>和主键索引</h3><p>利用主键自增id，我们如果知道了分页的上边界，以上查询可以改写为：<br><code>select xxx, xxx from test_table where id between xxxxx and xxxx</code>。</p>
<h3 id="利用自增主键索引、order-by加limit，不使用offset"><a href="#利用自增主键索引、order-by加limit，不使用offset" class="headerlink" title="利用自增主键索引、order by加limit，不使用offset"></a>利用自增主键索引、<code>order by</code>加<code>limit</code>，不使用offset</h3><p> <code>limit</code>和<code>offset</code>的问题，其实就是<code>offset</code>的问题，它会导致MySQL扫描大量不需要的行然后再抛弃掉。如果使用某个标签记录上一次所取数据的位置，那么下次就可以直接从书签位置开始扫描，这样就可以避免使用<code>offset</code>。</p>
<p> 例如以上查询可以改为:</p>
<p> 第一组数据：&#96;&#96;select xxx, xxxx from test_table order by id desc limit 20;</p>
<p> 这样就拿到了本次数据和下次数据的分解id值，则下一页查询就知道可以：<br><code>select xxx, xxx from test_table where id &lt; &#39;上页id分界值&#39; order by id desc limit 20</code></p>
<h2 id="熟悉并灵活使用explain"><a href="#熟悉并灵活使用explain" class="headerlink" title="熟悉并灵活使用explain"></a>熟悉并灵活使用<code>explain</code></h2><p>以下是mysql执行查询的整个过程，<code>explain</code>可以查看图中标红部分，</p>
<p><img src="/img/mysql_performace/mysql_performace.png"></p>
<p><code>explain</code>会展示很多字段和内容，其中的内容往往不好记，使用的时候，可以查看以下图解内容:<br><a href="https://i6448038.github.io/2019/02/07/explain-image">explain图解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/16/mysql-performance-optimize/" data-id="clzo46btn001uvajh6bdt9oys" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-explain-image" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/07/explain-image/" class="article-date">
  <time datetime="2019-02-07T10:14:35.000Z" itemprop="datePublished">2019-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/07/explain-image/">Mysql执行计划explain图解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在日常工作中，我们的项目如果发现查询很慢了，往往会去查看MySQL的慢查询日志，找到对应的SQL；<br>找到这个SQL并不就此完事儿了，还会对当前SQL进行优化；使用MySQL的explain命令，将会事半功倍！</p>
<p>但是就目前来看，explain指令的解析都是文字，大量的文字!一点不形象、不直观、使用的时候查起来也非常麻烦，因此，我做了一张表格，供大家参考和查阅。</p>
<p>以下是Mysql执行计划的图解。在使用explain的时候可以参考使用。</p>
<p>PS：图片若小，可保存放大使用。</p>
<p><img src="/img/explain/explain.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/07/explain-image/" data-id="clzo46btc000rvajhb4yib0i4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Golang-no-csp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/18/Golang-no-csp/" class="article-date">
  <time datetime="2018-12-18T14:36:18.000Z" itemprop="datePublished">2018-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/18/Golang-no-csp/">Golang非CSP并发模型外的其他并行方法总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Golang最为让人熟知的并发模型当属CSP并发模型，也就是由goroutine和channel构成的<a href="https://i6448038.github.io/2017/12/04/golang-concurrency-principle/">GMP并发模型</a>，具体内容不在赘述了，可以翻回之前的文章查看。在这里，要讲讲Golang的其他并发方式。</p>
<p>Golang不仅可以使用CSP并发模式，还可以使用传统的共享数据的并发模式。</p>
<h1 id="临界区-critical-section"><a href="#临界区-critical-section" class="headerlink" title="临界区(critical section)"></a>临界区(critical section)</h1><p>这是传统语言比较常用的的方式，即加锁。加锁使其线程同步，每次只允许一个goroutine进入某个代码块，此代码块区域称之为”*临界区(critical section)*”。</p>
<p>Golang为*临界区(critical section)*提供的是互斥锁的包和条件变量的包。</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>就是通常使用的锁，用来让线程串行用的。Golang提供了互斥锁<code>sync.Mutex</code>和读写互斥锁 <code>sync.RWMutex</code>，用法极其简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s sync.Mutex</span><br><span class="line">    </span><br><span class="line">s.Lock()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 这里的代码就是串行了，吼吼吼。。。</span></span><br><span class="line">    </span><br><span class="line">s.Unlock()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Lock和Unlock</p>
<h3 id="sync-Mutex和sync-RWMutex的区别"><a href="#sync-Mutex和sync-RWMutex的区别" class="headerlink" title="sync.Mutex和sync.RWMutex的区别"></a><code>sync.Mutex</code>和<code>sync.RWMutex</code>的区别</h3><p>没啥大的区别，只不过<code>sync.RWMutex</code>更加细腻，可以将“读操作”和“写操作”区别对待。<br><code>sync.RWMutex</code>中的Lock和unLock针对写操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s sync.RWMutex</span><br><span class="line"></span><br><span class="line">s.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上写锁了，吼吼</span></span><br><span class="line"></span><br><span class="line">s.Unlock()</span><br></pre></td></tr></table></figure>

<p><code>sync.RWMutex</code>中的RLock和RUnLock针对读操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s sync.RWMutex</span><br><span class="line"></span><br><span class="line">s.RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上读锁了，吼吼..</span></span><br><span class="line"></span><br><span class="line">s.RUnlock()</span><br></pre></td></tr></table></figure>

<p>读写锁有以下规则：</p>
<ul>
<li>写锁被锁定，（再试图进行）读锁和写锁都阻塞</li>
<li>读锁被锁定，（再试图进行）写锁阻塞，（再试图进行）读锁不阻塞</li>
</ul>
<p>即：多个写操作不能同时进行，写操作和读操作也不能同时进行，多个读操作可以同时进行</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>不要重复锁定互斥锁；因为代码写起来麻烦，容易出错，万一死锁(deadlock)了就废了。Go语言运行时系统自己抛出的panic都属于致命错误，都是无法恢复的，调用<code>recover</code>函数对它们起不到任何作用。一旦产生死锁，程序必然崩溃。</li>
<li>锁定和解锁一定要成对出现，如果怕忘记解锁，最好是使用<code>defer</code>语句来解锁；但是，一定不要对未锁定的或者已经锁定的互斥锁解锁，因为会触发<code>panic</code>，而且此<code>panic</code>和死锁一样，属于致命错误，程序肯定崩溃</li>
<li><code>sync.Mutex</code>是个结构体，尽量不要其当做参数，在多个函数直接传播。因为没啥意义，Golang的参数都是副本，多个副本之间都是相互独立的。</li>
</ul>
<h2 id="条件变量Cond"><a href="#条件变量Cond" class="headerlink" title="条件变量Cond"></a>条件变量Cond</h2><p>互斥锁是用来锁住资源，“创造”临界区的。而条件变量Cond可以认为是用来自行调度线程(在此即为groutine)的，当某个状态时，阻塞等待，当状态改变时，唤醒。</p>
<p>Cond的使用，离不开互斥锁，即离不开<code>sync.Mutex</code>和<code>sync.RWMutex</code>。<br>Cond初始化都需要有个互斥锁。（ps:哪怕初始化不需要，就应用场景而言，也得需要个互斥锁）</p>
<p><code>Cond</code>提供Wait、Signal、Broadcast 三种方法。<br>Wait表示线程(groutine)阻塞等待；<br>Signal表示唤醒等待的groutine；<br>Broadcast表示唤醒等待的所有groutine;</p>
<p>初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>在其中一个groutine中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cond.L.Lock()</span><br><span class="line"><span class="keyword">for</span> status == <span class="number">0</span> &#123;</span><br><span class="line">     cond.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//状态改变，goroutine被唤醒后，干点啥。。。</span></span><br><span class="line">cond.L.Unlock()</span><br></pre></td></tr></table></figure>
<p>以上算是模板</p>
<p>在另外一个groutine中:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cond.L.Lock()</span><br><span class="line">status = <span class="number">1</span></span><br><span class="line">cond.Signal() <span class="comment">// 或者使用cond.Broadcast()来唤醒以上groutine中沉睡的groutine</span></span><br><span class="line">cond.L.Unlock()</span><br></pre></td></tr></table></figure>


<h1 id="原子操作-atomicity"><a href="#原子操作-atomicity" class="headerlink" title="原子操作(atomicity)"></a>原子操作(atomicity)</h1><p>原子操作是硬件芯片级别的支持，所以可以保证绝对的线程安全。而且执行效率比其他方式要高出好几个数量级。</p>
<p>Go语言的原子操作当然也是基于CPU和操作系统的，Go语言提供的原子操作的包是<code>sync/atomic</code>，此包提供了加(Add)、CAS(交换并比较 compare and swap)、成对出现的存储(store)和加载(load)以及交换(swap)。</p>
<p>此包提供的大多数函数针对的数据类型也非常的单一：只有整型！使用方式十分的简单，看着函数直接调用就好。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int32</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">a = atomic.AddInt32(&amp;a, <span class="number">2</span>) <span class="comment">//此处是原子操作，就这么简单，吼吼</span></span><br></pre></td></tr></table></figure>

<p>在此特别强调一下CAS，CAS对应的函数前缀是“CompareAndSwap”，含义和用法正如英文翻译：比较并交换。在进行CAS操作的时候，函数会先判断被操作变量的当前值是否与我们预期的旧值相等，如果相等，它就把新值赋给该变量，并返回true，反之，就忽略此操作，并返回false。</p>
<p>可能是Golang提供的原子操作的数据类型实在是有限，Go又补充了一个结构体<code>atomic.Value</code>，此结构体相当于一个小容器，可以提供原子操作的存储<code>store</code>和提取<code>load</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> atomicVal atomic.Value</span><br><span class="line">str := <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">atomicVal.Store(str) <span class="comment">//此处是原子操作哦</span></span><br><span class="line"></span><br><span class="line">newStr := atomicVal.Load() <span class="comment">//此处是原子操作哦 </span></span><br></pre></td></tr></table></figure>


<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>为了能更好的调度goroutine，Go提供了<code>sync.WaitGroup</code>、<code>sync.Once</code>还有<code>context</code></p>
<h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a><code>sync.WaitGroup</code></h2><p><code>sync.WaitGroup</code>的作用就是在多goroutine并发程序中，让主goroutine等待所有goroutine执行结束。（直接查看代码注释）<br><code>sync.WaitGroup</code>提供了三个函数<code>Add</code>、<code>Done</code>和<code>Wait</code>三者用法如下：</p>
<ul>
<li>Add 写在主goroutine中，参数为将要运行的goroutine的数量</li>
<li>Done 写在各个非主goroutine中，表示运行结束</li>
<li>Wait 写在主goroutine中，block主goroutine，等待所有其他goroutine运行结束</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wait sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wait.Add(<span class="number">2</span>) <span class="comment">//必须是运行的goroutine的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//TODO 一顿小操作</span></span><br><span class="line">        <span class="keyword">defer</span> wait.Done() <span class="comment">// done函数用在goroutine中，表示goroutine操作结束</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//TODO 一顿小操作</span></span><br><span class="line">        <span class="keyword">defer</span> wait.Done() <span class="comment">// done函数用在goroutine中，表示goroutine操作结束</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wait.Wait() <span class="comment">// block住了，直到所有goroutine都结束</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>sync.WaitGroup</code>中有一个计数器，记录的是需要等待的goroutine的数量，默认值是0，可以通过Add方法来增加或者减少值，但是切记，千万不能让计数器的值小于零，会触发panic！</p>
<p><code>sync.WaitGroup</code>调用Wait方法的时候，<code>sync.WaitGroup</code>中计数器的值一定要为0。因此Add中的值一定要等于非主goroutine的数量！<br>且不要把Add和Wait方法放到不同的goroutine中执行！</p>
<h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a><code>sync.Once</code></h2><p>真真正正的只执行一次。</p>
<p><code>sync.Once</code>只要一个方法：<code>Do</code>，里面就一个参数:<code>func</code>。多说无益，复制下面代码，猜猜执行结果就知道了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Only once&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            once.Do(onceBody)</span><br><span class="line">            done &lt;- <span class="literal">true</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        &lt;-done</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Only once</span><br></pre></td></tr></table></figure>

<p>没错，只有一行。真只执行了一次。</p>
<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>context可以用来实现一对多的goroutine协作。这个包的应用场景主要是在API中。字面意思也很直接，上下文。当一个请求来时，会产生一个goroutine，但是这个goroutine往往要衍生出许多额外的goroutine去处理操作，例如链接database、请求rpc请求。。等等，这些衍生的goroutine和主goroutine有很多公用数据的，例如同一个请求生命周期、用户认证信息、token等，当这个请求超时或者被取消的时候，这里所有的goroutine都应该结束。context就可以帮助我们达到这个效果。</p>
<p>很显然，主goroutine和衍生的所有子goroutine之间形成了一颗树结构。我们的context可以从根节点遍布整棵树，当然，是线程安全的。</p>
<p>线程之间的基本是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(ctx context.Context, arg Arg)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ... use ctx ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个根context:background和todo；这两个根都是contenxt空的，没有值的。两者也没啥太本质的区别，Background是最常用的，作为Context这个树结构的最顶层的Context，它不能被取消。当不知道用啥context的时候就可以用TODO。</p>
<p>根生成子节点有以下方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成可撤销的Context (手动撤销)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成可定时撤销的Context (定时撤销)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"></span><br><span class="line"><span class="comment">//也是生成可定时撤销的Context (定时撤销)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可撤销的Context,可以存一个kv的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br></pre></td></tr></table></figure>

<h3 id="可撤销的Context"><a href="#可撤销的Context" class="headerlink" title="可撤销的Context"></a>可撤销的Context</h3><p>以下是每个方法的调用方式(全都来自godoc，可粘贴复用)：<br>可撤销的<code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gen := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    dst := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//只有撤销函数被调用后，才会触发</span></span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">case</span> dst &lt;- n:</span><br><span class="line">                n++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()  <span class="comment">//调用返回的cancel方法来让 context声明周期结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想结束所有线程，就调用<code>ctx, cancel := context.WithCancel(context.Background())</code>函数返回的cancel函数即可，当撤销函数被调用之后，对应的Context值会先关闭它内部的接收通道，也就是它的Done方法返回的通道。</p>
<p><code>WithDeadline</code>和<code>WithTimeout</code>用法基本类似，而且WithTimeout函数内部调用了WithDeadline函数。两者唯一区别是WithTimeout表示从现在开始xxx超时，而WithDeadline的时间可以是之前的时间：意思是说WithTimeout表示从现在开始， xxx时间后超时。而WithDeadline表示xx时间点，结束！这个时间点可以是昨天，时间点不收任何限制。</p>
<p>以下是godoc给出的列子：</p>
<p><code>WithDeadline</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d := time.Now().Add(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">    ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even though ctx will be expired, it is good practice to call its</span></span><br><span class="line">    <span class="comment">// cancelation function in any case. Failure to do so may keep the</span></span><br><span class="line">    <span class="comment">// context and its parent alive longer than necessary.</span></span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">//时间超时会自动调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;overslept&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context deadline exceeded</span><br></pre></td></tr></table></figure>

<p><code>WithTimeout</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Pass a context with a timeout to tell a blocking function that it</span></span><br><span class="line">    <span class="comment">// should abandon its work after the timeout elapses.</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">50</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">//时间超时会自动调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;overslept&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(ctx.Err()) <span class="comment">// prints &quot;context deadline exceeded&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context deadline exceeded</span><br></pre></td></tr></table></figure>

<h3 id="不可撤销的context，传递值"><a href="#不可撤销的context，传递值" class="headerlink" title="不可撤销的context，传递值"></a>不可撤销的context，传递值</h3><p><code>WithValue</code>可以用来在传递值的，值的存取是以KV的形式来进行的。直接上例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> favContextKey <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, k favContextKey)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> v := ctx.Value(k); v != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;found value:&quot;</span>, v)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key not found:&quot;</span>, k)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    k := favContextKey(<span class="string">&quot;language&quot;</span>)</span><br><span class="line">    k1 := favContextKey(<span class="string">&quot;Chinese&quot;</span>)</span><br><span class="line">    ctx := context.WithValue(context.Background(), k, <span class="string">&quot;Go&quot;</span>)</span><br><span class="line">    ctx1 := context.WithValue(ctx, k1, <span class="string">&quot;Go1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    f(ctx1, k1)</span><br><span class="line">    f(ctx1, k)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">found value: Go1</span><br><span class="line">found value: Go</span><br></pre></td></tr></table></figure>

<h2 id="请关注我"><a href="#请关注我" class="headerlink" title="请关注我"></a>请关注我</h2><p>更多精彩内容，请搜索我的微信公众号 <code>码农RyuGou</code></p>
<p>或者扫码<img src="/img/weichat/qrcode.jpg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/18/Golang-no-csp/" data-id="clzo46bt30005vajhdbgf9c3f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-raft" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/12/raft/" class="article-date">
  <time datetime="2018-12-12T10:18:07.000Z" itemprop="datePublished">2018-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/12/raft/">raft一致性算法详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在现实的分布式系统中，不能可能保证集群中的每一台机器都是100%可用可靠的，集群中的任何机器都可能发生宕机、网络连接等问题导致集群中的某个节点不可用，这样，那个节点的数据就有可能和集群不一致，所以需要有一种机制，来保证在大多数机器都存在的情况下向外提供可靠的数据服务。这里的大多数节点指的是<code>集群半数以上</code>的节点。</p>
<p>raft算法就是一种在分布式系统中解决集群中多节点之间数据一致性的算法。Golang生态圈中大名鼎鼎的etcd就是使用的raft算法来保持数据一致性的，与raft类似的一致性算法还有Paxos算法、Zab协议等。</p>
<p>其实，raft算法维持数据一致性的核心思想很简单，就是：“少数服从多数”。</p>
<h1 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h1><p>保证数据一致性，最好的方式就是只有唯一的一个节点，唯一的这个节点读，唯一的这个节点写，这样数据肯定是一致的；但是分布式架构显然不可以一个节点，于是，raft算法提出，在集群的所有节点中，需要有一个节点来充当这一个唯一的节点，在一段时间内，只有这一个节点负责读写数据，然后其他节点同步数据。这个唯一的节点叫<code>leader</code>节点，其他负责同步数据的节点叫做<code>follower</code>节点。在集群中，还会有其他状态的节点，例如<code>candidate</code>节点，这种节点只有在选举<code>leader</code>的时候才会有。<br>节点的<code>leader</code>选举和现实生活中的选举十分类似，就是投票，集群中获票数最多的那个，就是<code>leader</code>节点，所以为防止出现平局的情况(平局的情况也有解决方案，下文会说)，一般在部署节点的时候，会将节点数设置为奇数(2n + 1)。</p>
<p>这些节点是如何选举的呢？我们先从<code>follower</code>、<code>leader</code>、<code>candidate</code>这三种状态说起。<br>在集群中，有三个节点 A 、B、C。</p>
<!-- ![](/img/raft/WechatIMG8.jpeg) -->
<p><img src="/img/raft/1.jpeg"></p>
<p>在集群刚刚开始的时候，他们仨都是<code>follower</code>。</p>
<!-- ![](/img/raft/WechatIMG9.jpeg) -->
<p><img src="/img/raft/2.jpeg"></p>
<p>过一段时间后，A变成了<code>Candidate</code>，这是要选举了！</p>
<!-- ![](/img/raft/WechatIMG10.jpeg) -->
<p><img src="/img/raft/3.jpeg"></p>
<p>为啥A能变成<code>Candidate</code>？凭啥？因为A的<code>election timeout</code>到期了，<code>election timeout</code>是选举超时时间，集群中的每个节点都有一个<code>election timeout</code>，每个节点的<code>election timeout</code>都是150ms ~ 300ms之间的一个随机数。每当节点的<code>election timeout</code>时间到了，就会触发节点变为<code>candidate</code>状态。A的选举超时时间到了，所以A理所当然变为了<code>Candidate</code>。<br>所以，我们知道，其实A、B、C三个节点除了有状态，还有个选举超时时间<code>election timeout</code></p>
<!-- ![](/img/raft/WechatIMG11.jpeg) -->
<p><img src="/img/raft/4.jpeg"></p>
<p>此时，<code>candidate</code>节点A会向整个集群发起选举投票，它会先投自己一票，然后告诉B、C 大选开始了！</p>
<!-- ![](/img/raft/WechatIMG12.jpeg) -->
<p><img src="/img/raft/5.jpeg"></p>
<p>注意！只有<code>candidate</code>状态的节点，才可以参加竞选变为<code>leader</code>，B、C这两个follower是没有资格的！<br>除此之外，每个节点中还有一个字段，叫<code>term</code>意思就是任期，和美国大选的第几期总统差不多一个意思，这个<code>term</code>是一个全局的、连续递增的整数，每进行一次选举，<code>term</code>就会加一，如果<code>candidate</code>赢得选举，它会当<code>leader</code>直到此次任期结束。<br>此时，A触发了选举，它的<code>term</code>应该是加一的。</p>
<!-- ![](/img/raft/WechatIMG13.jpeg) -->
<p><img src="/img/raft/6.jpeg"></p>
<p>当B、C收到A发出的大选消息后，B、C开始投票，此时只有A这一个<code>candidate</code>，所以理所当然发消息都只能投A。</p>
<!-- ![](/img/raft/WechatIMG14.jpeg) -->
<p><img src="/img/raft/7.jpeg"></p>
<p>此时A当选<code>leader</code>!<br>为了巩固自己的“统治”，防止A在任期之间其他节点因为自身<code>election timout</code>而触发选举，<code>leader</code>节点A会不定时的向两个<code>follower</code>节点B、C发送心跳消息，B和C收到心跳消息后，会重置<code>election timout</code>。心跳检测时间很短，要远远小于选举超时时间<code>election timout</code>。</p>
<!-- ![](/img/raft/WechatIMG16.jpeg) -->
<p><img src="/img/raft/8.jpeg"></p>
<p>B、C收到心跳检测后，返回心跳响应，并重置超时时间<code>election timeout</code>。</p>
<!-- ![](/img/raft/WechatIMG17.jpeg) -->
<p><img src="/img/raft/9.jpeg"></p>
<p>假设A发送的心跳检测消息由于网络原因例如延迟、丢包等等没有传送到B、C中的某个Follower节点，而此时这个节点刚好<code>election timeout</code>，则触发选举。<br>C修改自身节点任期值<code>term</code>为2，自身状态变为<code>candidate</code>，且投自身一票后，发起选举！</p>
<!-- ![](/img/raft/WechatIMG19.jpeg) -->
<p><img src="/img/raft/10.jpeg"></p>
<p>这时候，由于C的任期值<code>term</code>变为2大于A的，在raft协议中，但收到任期值大于自身的节点，都会更改自身节点的term值，并切换为<code>Follower</code>状态并重置<code>election time</code>。<br>因此，这时候A由<code>leader</code>直接变为<code>Follower</code>！</p>
<!-- ![](/img/raft/WechatIMG20.jpeg) -->
<p><img src="/img/raft/11.jpeg"></p>
<p>我们再来考虑一种极端情况：假设有偶数个节点，并且同时有两个节点进入<code>candiate</code>状态！<br>例如有以下四个节点A、B、C、D。A和B同时进入了<code>cadidate</code>状态并开始选举。</p>
<!-- ![](/img/raft/WechatIMG21.jpeg) -->
<p><img src="/img/raft/12.jpeg"></p>
<p>假如A和B中任意一个获得了超过半数以上的多数票，则变为leader！</p>
<!-- ![](/img/raft/WechatIMG22.jpeg) -->
<p><img src="/img/raft/13.jpeg"></p>
<p>但是假如两个经过一次选举后得的票数相同或者都没有超过半数，则宣告选举失败并结束！等待A和C这两个<code>candidate</code>节点中任意一个节点的<code>election time</code>超时，然后发起新一轮选举。<br>注意：虽然票数相同或者都没有超过半数导致的选举失败了，但是任期值<code>term</code>还是要叠加的！<br>A、B票数相同，等待哪个先超时。</p>
<!-- ![](/img/raft/WechatIMG23.jpeg) -->
<p><img src="/img/raft/14.jpeg"></p>
<p>此时A先超时。则A发起选举，由于A<code>term</code>值显然是最大的，则A会最终当选为<code>leader</code>。</p>
<!-- ![](/img/raft/WechatIMG24.jpeg) -->
<p><img src="/img/raft/15.jpeg"></p>
<h1 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h1><p>当<code>leader</code>选出来后，无论读和写都会由<code>leader</code>节点来处理。<br>是的，读也由<code>leader</code>来处理，<code>leader</code>拿到请求后，再决定由哪一个节点来处理，要么将请求分发，要么自己处理；即使client端请求的是follower节点，Follower节点也会现将请求信息转给<code>leader</code>，再由<code>leader</code>决定由哪个节点来处理。</p>
<p>下面来说说写的情况：<br>以下有A、B、C三个节点，其中A是<code>leader</code>节点</p>
<!-- ![](/img/raft/WechatIMG25.jpeg) -->
<p><img src="/img/raft/16.jpeg"></p>
<p>当client请求过来要求写操作的时候，<code>leader</code> A先把数据写在本身节点的log文件中</p>
<!-- ![](/img/raft/WechatIMG26.jpeg) -->
<p><img src="/img/raft/17.jpeg"></p>
<p>然后A将发<code>append entries</code>消息发送给B、C节点。<br>注意！<code>append entries</code>消息其实是根据节点的不同而消息也不同的，因为集群中数据可能不一致，一味的传相同数据，显然不可以。具体怎么不一致，稍后再说。</p>
<!-- ![](/img/raft/WechatIMG36_new.jpeg) -->
<p><img src="/img/raft/18.jpeg"></p>
<p>B、C再收到消息后，把数据添加到本地，然后向A发消息，告诉A已经收到。</p>
<!-- ![](/img/raft/WechatIMG27.jpeg) -->
<p><img src="/img/raft/19.jpeg"></p>
<p><code>leader</code>A收到后，先提交记录，然后返回客户端响应。</p>
<!-- ![](/img/raft/WechatIMG28.jpeg) -->
<p><img src="/img/raft/20.jpeg"></p>
<p>然后，<code>leader</code>A继续向B、C两个follower发送写数据commit的通知。</p>
<!-- ![](/img/raft/WechatIMG29.jpeg) -->
<p><img src="/img/raft/21.jpeg"></p>
<p>B、C两个节点收到通知后，先commit自身的log数据，然后再通知<code>leader</code>A已更新结束。</p>
<!-- ![](/img/raft/WechatIMG30.jpeg) -->
<p><img src="/img/raft/22.jpeg"></p>
<p>到此整个数据同步也就结束了。<br>每次写数据，都需要先更新，然后commit。每个节点中都有两个索引，一个是当前提交的索引值commitIndex，一个是目前数据的最后一行索引值lastApplied。</p>
<!-- ![](/img/raft/WechatIMG31.jpeg) -->
<p><img src="/img/raft/23.jpeg"></p>
<p>而leader节点中，除了需要存储自身节点的commitIndex和lastApplied之外，还需要知道所有<code>Follower</code>的存储情况，因而<code>leader</code>节点中多了一张表，这张表中记录了所有<code>follower</code>节点的存储情况，这张表中有两个属性，一个属性叫<code>nextIndex</code>记录的是<code>Follower</code>节点没有的数据索引，需要发送<code>append entries</code>的数据索引；还有一个<code>matchIndex</code>记录的是<code>leader</code>节点已知的，<code>follower</code>节点的数据。如下图所示:</p>
<!-- ![](/img/raft/WechatIMG32.jpeg) -->
<p><img src="/img/raft/24.jpeg"></p>
<p>因此，当数据更新的时候，<code>leader</code>A 向节点B、C发送不同的<code>append entries</code>。</p>
<!-- ![](/img/raft/WechatIMG33.jpeg) -->
<p><img src="/img/raft/25.jpeg"></p>
<p>当A节点不再当leader时，其他节点并不能知道<code>leader</code>A保存的<code>matchIndex</code>和<code>nextIndex</code>这两个数组的数据。当其他节点成功当选为<code>leader</code>节点后，会将<code>nextIndex</code>全部重置为自身的<code>commitIndex</code>，而<code>matchIndex</code>则全部重置为0。如下图：</p>
<!-- ![](/img/raft/WechatIMG34.jpeg) -->
<p><img src="/img/raft/26.jpeg"></p>
<p>则，<code>leader</code>B会向A和C节点发<code>append entries</code>，去”补全”数据</p>
<!-- ![](/img/raft/WechatIMG35.jpeg) -->
<p><img src="/img/raft/27.jpeg"></p>
<p>节点收到请求后，如果存在数据，就不动直接返回，如果没有数据则缺哪个补哪个。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>触发选举的唯一条件是<code>election timeout</code>，心跳超时等其他条件仅仅是触发了非<code>leader</code>节点的<code>election timeout</code>。</li>
<li>节点选举的时候，<code>term</code>值大的一定会力压<code>term</code>值小的当选leader。</li>
<li><code>leader</code>节点向<code>follower</code>节点中发送<code>append entries</code>的时候，并不是缺少1、2、3就直接发送1、2、3而是分批次，一次发送一条。1！ 2！ 3！三条数据，分三次发完。(怕图片误导，特此说明!)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/12/raft/" data-id="clzo46btq0023vajh4o0j0oaf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Golang-interface" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/01/Golang-interface/" class="article-date">
  <time datetime="2018-09-30T18:04:16.000Z" itemprop="datePublished">2018-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/01/Golang-interface/">Go语言interface底层实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Go的interface源码在Golang源码的<code>runtime</code>目录中。<br>Go在不同版本之间的interface结构可能会有所不同，但是，整体的结构是不会改变的，此文章用的Go版本是1.11。</p>
<p>Go的interface是由两种类型来实现的：<code>iface</code>和<code>eface</code>。<br>其中，<code>iface</code>表示的是包含方法的interface，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>eface</code>代表的是不包含方法的interface，即</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person <span class="keyword">interface</span>&#123;&#125; = xxxx实体</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="eface"><a href="#eface" class="headerlink" title="eface"></a><code>eface</code></h2><p><code>eface</code>的具体结构是：<br><img src="/img/interface/eface.png" alt="在这里插入图片描述"><br>一共有两个属性构成，一个是类型信息<code>_type</code>，一个是数据信息。<br>其中，<code>_type</code>可以认为是Go语言中所有类型的公共描述，Go语言中几乎所有的数据结构都可以抽象成<code>_type</code>，是所有类型的表现，可以说是万能类型，<br><code>data</code>是指向具体数据的指针。</p>
<p><code>type</code>的具体代码为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">	size       <span class="type">uintptr</span> </span><br><span class="line">	ptrdata    <span class="type">uintptr</span> <span class="comment">// size of memory prefix holding all pointers</span></span><br><span class="line">	hash       <span class="type">uint32</span></span><br><span class="line">	tflag      tflag</span><br><span class="line">	align      <span class="type">uint8</span></span><br><span class="line">	fieldalign <span class="type">uint8</span></span><br><span class="line">	kind       <span class="type">uint8</span></span><br><span class="line">	alg        *typeAlg</span><br><span class="line">	<span class="comment">// gcdata stores the GC type data for the garbage collector.</span></span><br><span class="line">	<span class="comment">// If the KindGCProg bit is set in kind, gcdata is a GC program.</span></span><br><span class="line">	<span class="comment">// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.</span></span><br><span class="line">	gcdata    *<span class="type">byte</span></span><br><span class="line">	str       nameOff</span><br><span class="line">	ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>eface</code>的整体结构是：<br><img src="/img/interface/eface_all.png" alt="在这里插入图片描述"><br>对于没有方法的interface赋值后的内部结构是怎样的呢？<br>可以先看段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Binary <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := Binary(<span class="number">200</span>)</span><br><span class="line">	any := (<span class="keyword">interface</span>&#123;&#125;)(b)</span><br><span class="line">	fmt.Println(any)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出200，赋值后的结构图是这样的：<br><img src="/img/interface/eface_fuzhi.png" alt="在这里插入图片描述"><br>对于将不同类型转化成<code>type</code>万能结构的方法，是运行时的<code>convT2E</code>方法，在<code>runtime</code>包中。<br>以上，是对于没有方法的接口说明。<br>对于包含方法的函数，用到的是另外的一种结构，叫<code>iface</code></p>
<h1 id="iface"><a href="#iface" class="headerlink" title="iface"></a><code>iface</code></h1><p>所有包含方法的接口，都会使用<code>iface</code>结构。包含方法的接口就是一下这种最常见，最普通的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">interface</span> &#123;</span><br><span class="line">	Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>iface</code>的源代码是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>iface</code>的具体结构是：</p>
<p><img src="/img/interface/iface.png" alt="在这里插入图片描述"></p>
<p><code>itab</code>是<code>iface</code>不同于<code>eface</code>比较关键的数据结构。其可包含两部分：一部分是确定唯一的包含方法的interface的具体结构类型，一部分是指向具体方法集的指针。<br>具体结构为：<br><img src="/img/interface/iface_itable.png" alt="在这里插入图片描述"><br>属性 <code>itab</code>的源代码是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">	inter *interfacetype <span class="comment">//此属性用于定位到具体interface</span></span><br><span class="line">	_type *_type <span class="comment">//此属性用于定位到具体interface</span></span><br><span class="line">	hash  <span class="type">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">	_     [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line">	fun   [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// variable sized. fun[0]==0 means _type does not implement inter.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性<code>interfacetype</code>类似于<code>_type</code>，其作用就是interface的公共描述，类似的还有<code>maptype</code>、<code>arraytype</code>、<code>chantype</code>…其都是各个结构的公共描述，可以理解为一种外在的表现信息。<code>interfacetype</code>源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ     _type</span><br><span class="line">	pkgpath name</span><br><span class="line">	mhdr    []imethod</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> imethod <span class="keyword">struct</span> &#123;</span><br><span class="line">	name nameOff</span><br><span class="line">	ityp typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>iface</code>的整体结构为：</p>
<p><img src="/img/interface/iface_all.png" alt="在这里插入图片描述"></p>
<p>对于含有方法的interface赋值后的内部结构是怎样的呢？<br>一下代码运行后</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Binary <span class="type">uint64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strconv.FormatUint(i.Get(), <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Binary)</span></span> Get() <span class="type">uint64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">uint64</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := Binary(<span class="number">200</span>)</span><br><span class="line">	any := fmt.Stringer(b)</span><br><span class="line">	fmt.Println(any)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，要知道代码运行结果为:200。<br>其次，了解到<code>fmt.Stringer</code>是一个包含<code>String</code>方法的接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，赋值后接口<code>Stringer</code>的内部结构为：<br><img src="/img/interface/iface_fuzhi.png" alt="在这里插入图片描述"></p>
<p>对于将不同类型转化成itable中<code>type(Binary)</code>的方法，是运行时的<code>convT2I</code>方法，在<code>runtime</code>包中。</p>
<h2 id="请关注我"><a href="#请关注我" class="headerlink" title="请关注我"></a>请关注我</h2><p>更多精彩内容，请搜索我的微信公众号 <code>码农RyuGou</code></p>
<p>或者扫码<img src="/img/weichat/qrcode.jpg"></p>
<p>参考文献：<br>《Go in action》<br><a href="https://research.swtch.com/interfaces">https://research.swtch.com/interfaces</a><br><a href="https://juejin.im/entry/5a7d08d3f265da4e865a6200">https://juejin.im/entry/5a7d08d3f265da4e865a6200</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/01/Golang-interface/" data-id="clzo46bsv0001vajhgt9mfkh7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-map-secret" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/26/map-secret/" class="article-date">
  <time datetime="2018-08-25T18:43:04.000Z" itemprop="datePublished">2018-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/26/map-secret/">解剖Go语言map底层实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>map</code>是Go语言中基础的数据结构，在日常的使用中经常被用到。但是它底层是如何实现的呢？</p>
<p>Golang中<code>map</code>的底层实现是一个散列表，因此实现<code>map</code>的过程实际上就是实现散表的过程。在这个散列表中，主要出现的结构体有两个，一个叫<code>hmap</code>(<code>a header for a go map</code>)，一个叫<code>bmap</code>(<code>a bucket for a Go map</code>，通常叫其<code>bucket</code>)。这两种结构的样子分别如下所示：<br>hmap:</p>
<img src="/img/go_map/hmap.png" />

<p>图中有很多字段，但是便于理解<code>map</code>的架构，你只需要关心的只有一个，就是标红的字段：buckets数组。Golang的map中用于存储的结构是bucket数组。而bucket(即<code>bmap</code>)的结构是怎样的呢？</p>
<p>bucket：</p>
<img src="/img/go_map/bmap.png" />

<p>相比于<code>hmap</code>，bucket的结构显得简单一些，标红的字段依然是“核心”，我们使用的<code>map</code>中的key和value就存储在这里。“高位哈希值”数组记录的是当前bucket中key相关的“索引”，稍后会详细叙述。还有一个字段是一个指向扩容后的bucket的指针，使得bucket会形成一个链表结构。例如下图：</p>
<img src="/img/go_map/bmap_chain.png" />

<p>由此看出<code>hmap</code>和<code>bucket</code>的关系是这样的：</p>
<p><img src="/img/go_map/hmap_bmap.png" alt="这里写图片描述"></p>
<p>而bucket又是一个链表，所以，整体的结构应该是这样的：</p>
<p><img src="/img/go_map/whole.png" alt="这里写图片描述"></p>
<p>哈希表的特点是会有一个哈希函数，对你传来的key进行哈希运算，得到唯一的值，一般情况下都是一个数值。Golang的<code>map</code>中也有这么一个哈希函数，也会算出唯一的值，对于这个值的使用，Golang也是很有意思。</p>
<p>Golang把求得的值按照用途一分为二：高位和低位。</p>
<p><img src="/img/go_map/num.png" alt="这里写图片描述"></p>
<p>如图所示，蓝色为高位，红色为低位。<br>然后低位用于寻找当前key属于<code>hmap</code>中的哪个bucket，而高位用于寻找bucket中的哪个key。上文中提到：bucket中有个属性字段是“高位哈希值”数组，这里存的就是蓝色的高位值，用来声明当前bucket中有哪些“key”，便于搜索查找。<br>需要特别指出的一点是：我们<code>map</code>中的key&#x2F;value值都是存到同一个数组中的。数组中的顺序是这样的:</p>
<p><img src="/img/go_map/key_value.png" alt="这里写图片描述"></p>
<p>并不是key0&#x2F;value0&#x2F;key1&#x2F;value1的形式，这样做的好处是：在key和value的长度不同的时候，可以消除padding带来的空间浪费。</p>
<p>现在，我们可以得到Go语言<code>map</code>的整个的结构图了：</p>
<p><img src="/img/go_map/all_elem.png" alt="这里写图片描述"></p>
<h1 id="map的扩容"><a href="#map的扩容" class="headerlink" title="map的扩容"></a><code>map</code>的扩容</h1><p>当以上的哈希表增长的时候，Go语言会将bucket数组的数量扩充一倍，产生一个新的bucket数组，并将旧数组的数据迁移至新数组。</p>
<h2 id="加载因子"><a href="#加载因子" class="headerlink" title="加载因子"></a>加载因子</h2><p>判断扩充的条件，就是哈希表中的<code>加载因子</code>(即loadFactor)。</p>
<p><code>加载因子</code>是一个阈值，一般表示为：散列包含的元素数 除以 位置总数。是一种“产生冲突机会”和“空间使用”的平衡与折中：<code>加载因子</code>越小，说明空间空置率高，空间使用率小，但是<code>加载因子</code>越大，说明空间利用率上去了，但是“产生冲突机会”高了。</p>
<p>每种哈希表的都会有一个<code>加载因子</code>，数值超过<code>加载因子</code>就会为哈希表扩容。<br>Golang的<code>map</code>的<code>加载因子</code>的公式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map长度 / 2^B</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>阈值是<code>6.5</code>。其中<code>B</code>可以理解为已扩容的次数。<br>当Go的<code>map</code>长度增长到大于<code>加载因子</code>所需的<code>map</code>长度时，Go语言就会将产生一个新的bucket数组，然后把旧的bucket数组移到一个属性字段<code>oldbucket</code>中。注意：并不是立刻把旧的数组中的元素转义到新的bucket当中，而是，只有当访问到具体的某个bucket的时候，会把bucket中的数据转移到新的bucket中。</p>
<p>如下图所示：当扩容的时候，Go的<code>map</code>结构体中，会保存旧的数据，和新生成的数组</p>
<p><img src="/img/go_map/extends.png" alt="这里写图片描述"></p>
<p>上面部分代表旧的有数据的bucket，下面部分代表新生成的新的bucket。蓝色代表存有数据的bucket，橘黄色代表空的bucket。<br>扩容时<code>map</code>并不会立即把新数据做迁移，而是当访问原来旧bucket的数据的时候，才把旧数据做迁移，如下图：</p>
<p><img src="/img/go_map/move_bucket.png" alt="这里写图片描述"></p>
<p>注意：这里并不会直接删除旧的bucket，而是把原来的引用去掉，利用GC清除内存。</p>
<h1 id="map中数据的删除"><a href="#map中数据的删除" class="headerlink" title="map中数据的删除"></a><code>map</code>中数据的删除</h1><p>如果理解了<code>map</code>的整体结构，那么查找、更新、删除的基本步骤应该都很清楚了。这里不再赘述。<br>值得注意的是，找到了<code>map</code>中的数据之后，针对key和value分别做如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、如果``key``是一个指针类型的，则直接将其置为空，等待GC清除；</span><br><span class="line">2、如果是值类型的，则清除相关内存。</span><br><span class="line">3、同理，对``value``做相同的操作。</span><br><span class="line">4、最后把key对应的高位值对应的数组index置为空。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/26/map-secret/" data-id="clzo46btm001pvajh689kg8e3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-array-and-slice-principle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/11/array-and-slice-principle/" class="article-date">
  <time datetime="2018-08-11T08:36:24.000Z" itemprop="datePublished">2018-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/11/array-and-slice-principle/">快速理解Go数组和切片的内部实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>   很多人对Go语言的<code>array</code>和<code>slice</code>傻傻分不清楚，今天我们就从底层出发，来聊聊它俩到底有什么区别。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>   几乎所有计算机语言，数组的实现都是相似的：一段连续的内存，Go语言也一样，Go语言的数组底层实现就是一段连续的内存空间。每个元素有唯一一个索引(或者叫<code>下标</code>)来访问。如下图所示，下图是<code>[5]int&#123;1:10, 2:20&#125;</code>数组的内部实现逻辑图:</p>
<p><img src="/img/slice/array.png" alt="image"></p>
<p>  由于内存连续，CPU很容易计算索引(即数组的<code>下标</code>)，可以快速迭代数组里的所有元素。<br>  Go语言的数组不同于C语言或者其他语言的数组，C语言的数组变量是指向数组第一个元素的指针；而Go语言的数组是一个值，Go语言中的数组是值类型，一个数组变量就表示着整个数组，意味着Go语言的数组在传递的时候，传递的是原数组的拷贝。你可以理解为Go语言的数组是一种有序的<code>struct</code></p>
<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p>  切片是一个很小的对象，是对数组进行了抽象，并提供相关的操作方法。切片有三个属性字段：长度、容量和指向数组的指针。</p>
<p>  <img src="/img/slice/slice_1.png" alt="image"></p>
<p>  上图中，<code>ptr</code>指的是指向array的pointer，<code>len</code>是指切片的长度, <code>cap</code>指的是切片的容量。现在，我想你对数组和切片有了一个本质的认识。</p>
<h2 id="切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？"><a href="#切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？" class="headerlink" title="切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？"></a>切片有多种声明方式，每种初始化方式对应的逻辑图是怎样的呢？</h2><h3 id="对于s-make-byte-5-和s-byte-的方式"><a href="#对于s-make-byte-5-和s-byte-的方式" class="headerlink" title="对于s := make([]byte, 5)和s := []byte{...}的方式"></a>对于<code>s := make([]byte, 5)</code>和<code>s := []byte&#123;...&#125;</code>的方式</h3><p>  <img src="/img/slice/slice2.png" alt="image"></p>
<h3 id="对于s-s-2-4-的方式"><a href="#对于s-s-2-4-的方式" class="headerlink" title="对于s = s[2:4]的方式"></a>对于<code>s = s[2:4]</code>的方式</h3><p>  <img src="/img/slice/slice3.png" alt="image"></p>
<h3 id="对于nil的切片即var-s-byte对应的逻辑图是"><a href="#对于nil的切片即var-s-byte对应的逻辑图是" class="headerlink" title="对于nil的切片即var s []byte对应的逻辑图是"></a>对于<code>nil</code>的切片即<code>var s []byte</code>对应的逻辑图是</h3><p>  <img src="/img/slice/slice4.png" alt="image"></p>
<p>  在此有一个说明：<code>nil</code>切片和<code>空</code>切片是不太一样的，空切片即<code>s := make([]byte, 0) </code>或者<code>s := []byte&#123;&#125;</code>出来的切片<br>  空切片的逻辑图为：</p>
<p>  <img src="/img/slice/slice5.png" alt="image"></p>
<p>  空切片指针不为nil，而nil切片指针为nil。但是，不管是空切片还是nil切片，对其调用内置函数<code>append()</code>、<code>len</code>和<code>cap</code>的效果都是一样的，感受不到任何区别。</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>  slice这种数据结构便于使用和管理数据集合，可以理解为是一种“动态数组”，<code>slice</code>也是围绕动态数组的概念来构建的。既然是动态数组，那么slice是如何扩容的呢？</p>
<p>  请记住以下两条规则：</p>
<ul>
<li>如果切片的容量小于1024个元素，那么扩容的时候slice的cap就翻番，乘以2；一旦元素个数超过1024个元素，增长因子就变成1.25，即每次增加原来容量的四分之一。</li>
<li>如果扩容之后，还没有触及原数组的容量，那么，切片中的指针指向的位置，就还是原数组，如果扩容之后，超过了原数组的容量，那么，Go就会开辟一块新的内存，把原来的值拷贝过来，这种情况丝毫不会影响到原数组。</li>
</ul>
<p>知道了一下规则，请看下面程序,试问输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    arr := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">    slice := arr[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    testSlice1 := slice</span><br><span class="line">    testSlice2 := <span class="built_in">append</span>(<span class="built_in">append</span>(<span class="built_in">append</span>(slice, <span class="number">1</span>),<span class="number">2</span>),<span class="number">3</span>)</span><br><span class="line">    slice[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">  </span><br><span class="line">    fmt.Println(testSlice1[<span class="number">0</span>])</span><br><span class="line">    fmt.Println(testSlice2[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>答对了吗？</p>
<p>参考文献:<br>《Go in action》<br><a href="https://blog.golang.org/go-slices-usage-and-internals">https://blog.golang.org/go-slices-usage-and-internals</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/11/array-and-slice-principle/" data-id="clzo46bt9000ivajh7ovt0n03" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-golang-mistakes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/golang-mistakes/" class="article-date">
  <time datetime="2018-07-17T16:17:28.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/golang-mistakes/">golang错题集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文即<a href="https://i6448038.github.io/2017/07/28/GolangDetails/">Go语言的那些坑</a>三。</p>
<h1 id="不要对Go并发函数的执行时机做任何假设"><a href="#不要对Go并发函数的执行时机做任何假设" class="headerlink" title="不要对Go并发函数的执行时机做任何假设"></a>不要对Go并发函数的执行时机做任何假设</h1><p>请看下列的列子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	names := []<span class="type">string</span>&#123;<span class="string">&quot;lily&quot;</span>, <span class="string">&quot;yoyo&quot;</span>, <span class="string">&quot;cersei&quot;</span>, <span class="string">&quot;rose&quot;</span>, <span class="string">&quot;annei&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> names&#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">			fmt.Println(name)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问输出什么？</p>
<p>答案:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br><span class="line">annei</span><br></pre></td></tr></table></figure>
<p>为什么呢？是不是有点诧异？<br>输出的都是“annei”，而“annei”又是“names”的最后一个元素，那么也就是说程序打印出了最后一个元素的值，而name对于匿名函数来讲又是一个外部的值。因此，我们可以做一个推断：虽然每次循环都启用了一个协程，但是这些协程都是引用了外部的变量，当协程创建完毕，再执行打印动作的时候，name的值已经不知道变为啥了，因为主函数协程也在跑，大家并行，但是在此由于names数组长度太小，当协程创建完毕后，主函数循环早已结束，所以，打印出来的都是遍历的names最后的那一个元素“annei”。<br>如何证实以上的推断呢？<br>其实很简单，每次循环结束后，停顿一段时间，等待协程打印当前的name便可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	names := []<span class="type">string</span>&#123;<span class="string">&quot;lily&quot;</span>, <span class="string">&quot;yoyo&quot;</span>, <span class="string">&quot;cersei&quot;</span>, <span class="string">&quot;rose&quot;</span>, <span class="string">&quot;annei&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> _, name := <span class="keyword">range</span> names&#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">			fmt.Println(name)</span><br><span class="line">		&#125;()</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">	runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lily</span><br><span class="line">yoyo</span><br><span class="line">cersei</span><br><span class="line">rose</span><br><span class="line">annei</span><br></pre></td></tr></table></figure>
<p>以上我们得出一个结论，不要对“go函数”的执行时机做任何的假设，除非你确实能做出让这种假设成为绝对事实的保证。</p>
<h1 id="假设T类型的方法上接收器既有T类型的，又有-T指针类型的，那么就不可以在不能寻址的T值上调用-T接收器的方法"><a href="#假设T类型的方法上接收器既有T类型的，又有-T指针类型的，那么就不可以在不能寻址的T值上调用-T接收器的方法" class="headerlink" title="假设T类型的方法上接收器既有T类型的，又有*T指针类型的，那么就不可以在不能寻址的T值上调用*T接收器的方法"></a>假设T类型的方法上接收器既有<code>T</code>类型的，又有<code>*T</code>指针类型的，那么就不可以在不能寻址的T值上调用<code>*T</code>接收器的方法</h1><p>请看代码,试问能正常编译通过吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Lili <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili *Lili)</span></span> fmtPointer()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;poniter&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili Lili)</span></span> fmtReference()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;reference&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	li := Lili&#123;&#125;</span><br><span class="line">	li.fmtPointer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能正常编译通过，并输出&quot;poniter&quot;</span><br></pre></td></tr></table></figure>

<p>感觉有点诧异，请接着看以下的代码，试问能编译通过？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Lili <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili *Lili)</span></span> fmtPointer()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;poniter&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili Lili)</span></span> fmtReference()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;reference&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Lili&#123;&#125;.fmtPointer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不能编译通过。</span><br><span class="line">“cannot call pointer method on Lili literal”</span><br><span class="line">“cannot take the address of Lili literal”</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>是不是有点奇怪？这是为什么呢？其实在第一个代码示例中，main主函数中的“li”是一个变量，li的虽然是类型Lili，但是li是可以寻址的，&amp;li的类型是<code>*Lili</code>，因此可以调用*Lili的方法。</p>
<h1 id="一个包含nil指针的接口不是nil接口"><a href="#一个包含nil指针的接口不是nil接口" class="headerlink" title="一个包含nil指针的接口不是nil接口"></a>一个包含nil指针的接口不是nil接口</h1><p>请看下列代码，试问返回什么</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> debug&#123;</span><br><span class="line">		buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	&#125;</span><br><span class="line">	f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;surprise!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是输出：surprise。<br>ok，让我们吧<code>debug</code>开关关掉，及<code>debug</code>的值变为<code>false</code>。那么输出什么呢？是不是什么都不输出？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> debug&#123;</span><br><span class="line">		buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	&#125;</span><br><span class="line">	f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;surprise!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>答案是：依然输出surprise。</p>
<p>这是为什么呢？<br>这就牵扯到一个概念了，是关于接口值的。概念上讲一个接口的值分为两部分：一部分是类型，一部分是类型对应的值，他们分别叫：动态类型和动态值。类型系统是针对编译型语言的，类型是编译期的概念，因此类型不是一个值。<br>在上述代码中，给f函数的out参数赋了一个<code>*bytes.Buffer</code>的空指针，所以out的动态值是nil。然而它的动态类型是*bytes.Buffer，意思是：“A non-nil interface containing a nil pointer”，所以“out!&#x3D;nil”的结果依然是true。<br>但是，对于直接的<code>*bytes.Buffer</code>类型的判空不会出现此问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf *bytes.Buffer</span><br><span class="line">	<span class="keyword">if</span> buf == <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;right&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是输出: right<br>只有 接口指针 传入函数的接口参数时，才会出现以上的坑。<br>修改起来也很方便，把<code>*bytes.Buffer</code>改为<code>io.Writer</code>就好了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> debug = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf  io.Writer <span class="comment">//原来是var buf *bytes.Buffer</span></span><br><span class="line">	<span class="keyword">if</span> debug&#123;</span><br><span class="line">		buf = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	&#125;</span><br><span class="line">	f(buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out io.Writer)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;surprise!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关"><a href="#将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关" class="headerlink" title="将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关"></a>将map转化为json字符串的时候，json字符串中的顺序和map赋值顺序无关</h1><p>请看下列代码，请问输出什么？若为json字符串，则json字符串中key的顺序是什么？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	params := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	params[<span class="string">&quot;id&quot;</span>] = <span class="string">&quot;1&quot;</span></span><br><span class="line">	params[<span class="string">&quot;id1&quot;</span>] = <span class="string">&quot;3&quot;</span></span><br><span class="line">	params[<span class="string">&quot;controller&quot;</span>] = <span class="string">&quot;sections&quot;</span></span><br><span class="line"></span><br><span class="line">	data, _ := json.Marshal(params)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：输出<code>&#123;&quot;controller&quot;:&quot;sections&quot;,&quot;id&quot;:&quot;1&quot;,&quot;id1&quot;:&quot;3&quot;&#125;</code><br>利用Golang自带的json转换包转换，会将map中key的顺序改为字母顺序，而不是map的赋值顺序。map这个结构哪怕利用<code>for range </code>遍历的时候,其中的key也是无序的，可以理解为map就是个无序的结构，和php中的array要区分开来</p>
<h1 id="Json反序列化数字到interface-类型的值中，默认解析为float64类型"><a href="#Json反序列化数字到interface-类型的值中，默认解析为float64类型" class="headerlink" title="Json反序列化数字到interface{}类型的值中，默认解析为float64类型"></a>Json反序列化数字到interface{}类型的值中，默认解析为float64类型</h1><p>请看以下程序，程序想要输出json数据中整型<code>id</code>加上<code>3</code>的值,请问程序会报错吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	jsonStr := <span class="string">`&#123;&quot;id&quot;:1058,&quot;name&quot;:&quot;RyuGou&quot;&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> jsonData <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;jsonData)</span><br><span class="line"></span><br><span class="line">	sum :=  jsonData[<span class="string">&quot;id&quot;</span>].(<span class="type">int</span>) + <span class="number">3</span></span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答案是会报错，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: interface &#123;&#125; is float64, not int</span><br></pre></td></tr></table></figure>
<p>使用 Golang 解析 JSON  格式数据时，若以 interface{} 接收数据，则会按照下列规则进行解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool, for JSON booleans</span><br><span class="line"></span><br><span class="line">float64, for JSON numbers</span><br><span class="line"></span><br><span class="line">string, for JSON strings</span><br><span class="line"></span><br><span class="line">[]interface&#123;&#125;, for JSON arrays</span><br><span class="line"></span><br><span class="line">map[string]interface&#123;&#125;, for JSON objects</span><br><span class="line"></span><br><span class="line">nil for JSON null</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应该改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	jsonStr := <span class="string">`&#123;&quot;id&quot;:1058,&quot;name&quot;:&quot;RyuGou&quot;&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> jsonData <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;jsonData)</span><br><span class="line"></span><br><span class="line">	sum :=  <span class="type">int</span>(jsonData[<span class="string">&quot;id&quot;</span>].(<span class="type">float64</span>)) + <span class="number">3</span></span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用-来给全局变量赋值"><a href="#即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用-来给全局变量赋值" class="headerlink" title="即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用:=来给全局变量赋值"></a>即使在有多个变量、且有的变量存在有的变量不存在、且这些变量共同赋值的情况下，也不可以使用<code>:=</code>来给全局变量赋值</h1><p><code>:=</code>往往是用来声明局部变量的，在多个变量赋值且有的值存在的情况下，<code>:=</code>也可以用来赋值使用,例如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msgStr := <span class="string">&quot;hello wolrd&quot;</span></span><br><span class="line">msgStr, err := <span class="string">&quot;hello&quot;</span>, errors.New(<span class="string">&quot;xxx&quot;</span>)<span class="comment">//err并不存在</span></span><br></pre></td></tr></table></figure>
<p>但是，假如全局变量也使用类似的方式赋值，就会出现问题，请看下列代码，试问能编译通过吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varTest <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	varTest, err := function()</span><br><span class="line">	fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span></span>(<span class="type">string</span>, <span class="type">error</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>, errors.New(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>答案是：通不过。输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">varTest declared and not used</span><br></pre></td></tr></table></figure>

<p>但是如果改成如下代码，就可以通过：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> varTest <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	err := errors.New(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">	varTest, err = function()</span><br><span class="line">	fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function</span><span class="params">()</span></span>(<span class="type">string</span>, <span class="type">error</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>, errors.New(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error</span><br></pre></td></tr></table></figure>
<p>这是什么原因呢？<br>答案其实很简单，在<code>test</code>方法中，如果使用<code>varTest, err := function()</code>这种方式的话，相当于在函数中又定义了一个和全局变量<code>varTest</code>名字相同的局部变量，而这个局部变量又没有使用，所以会编译不通过。</p>
<h1 id="interface-是一个指向interface的指针类型，而不是interface类型"><a href="#interface-是一个指向interface的指针类型，而不是interface类型" class="headerlink" title="*interface 是一个指向interface的指针类型，而不是interface类型"></a>*interface 是一个指向interface的指针类型，而不是interface类型</h1><p>请问以下代码，能编译通过吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Child)</span></span>Hello()  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf  Child</span><br><span class="line">	buf = Child&#123;&#125;</span><br><span class="line">	f(&amp;buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out *Father)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;surprise!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是：不能编译通过。输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*Father is pointer to interface, not interface</span><br></pre></td></tr></table></figure>
<p>注意了：接口类型的变量可以被赋值为实现接口的结构体的实例，但是并不能代表接口的指针可以被赋值为实现接口的结构体的指针实例。即：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf Father = Child&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>是对的，但是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf *Father = <span class="built_in">new</span>(Child)</span><br></pre></td></tr></table></figure>
<p>却是不对的。应该改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf Father = Child&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> pointer *Father = &amp;buf</span><br></pre></td></tr></table></figure>
<p>要想让问题最开始的代码编译通过要将以上代码修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Father <span class="keyword">interface</span> &#123;</span><br><span class="line">	Hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Child <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Child)</span></span>Hello()  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> buf  Father</span><br><span class="line">	buf = Child&#123;&#125;</span><br><span class="line">	f(&amp;buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(out *Father)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> out != <span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;surprise!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/18/golang-mistakes/" data-id="clzo46bti001avajh3bhfdx5g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-bitcoin-and-blockchain" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/08/bitcoin-and-blockchain/" class="article-date">
  <time datetime="2018-05-08T15:34:47.000Z" itemprop="datePublished">2018-05-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/08/bitcoin-and-blockchain/">比特币和区块链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="比特币及区块链的发展历史"><a href="#比特币及区块链的发展历史" class="headerlink" title="比特币及区块链的发展历史"></a>比特币及区块链的发展历史</h3><p>   大家接触和了解区块链，最早应该是从比特币开始的。确实，区块链确实也是起源于比特币，但是又不局限于货币圈。区块链可以在金融、保险、医疗、政府等领域被广泛使用。<br>    既然区块链起源于货币，那我们就从货币开始谈起。<br>    货币本质上是一种所有者与市场关于交换权的契约，根本上是所有者相互之间的约定。<br>    货币的发展从物物交换到现在的纸币、电子货币经历了漫长的过程。当初稀有的贝壳、金银等作为一般等价物，现在广泛使用纸币，纸币的制作成本也许只有几厘钱，但是却可以换取价值数百元或者更多的物品，原因是有国家的信用背书做约定，让人们相信几张制作成本为几厘钱的纸币，可以获取实际价值几百元的物品。近几年，电子货币已经走入人们的生活，每个人每笔钱的收入与支出仅仅是银行系统对于一个数字的加减，每笔交易也是银行在记账，并且，只有银行有记账权。</p>
<p>2008年全球经济危机中，因为美国政府拥有记账权，所以可以无限增发货币。一个叫中本聪觉得这样很不合理，于是他想出了一种新型支付体系系统：大家都有权来记账，货币不能超发，而且整个账本完全公开透明。这就是比特币产生的原因和动机。</p>
<p>中本聪在2008年全球金融危机爆发之后，在网上发表了一篇论文：《比特币：一种点对点式的电子现金系统》（Bitcoin: A Peer-to-Peer Electronic Cash System），文中描述了一种全新的、一种总量恒定、去中心化的电子现金系统的发行和流通问题，在这个系统中，信息公开透明，每一笔转账都会被全网记录。这篇论文就是所谓的比特币白皮书，这篇论文的问世，标志着比特币底层技术区块链的诞生。</p>
<h3 id="中本聪是谁？"><a href="#中本聪是谁？" class="headerlink" title="中本聪是谁？"></a>中本聪是谁？</h3><p>中本聪是比特币的开发者兼创始者，密码朋克邮件组成员之一（密码朋克可以算是一个极客组织，组织早起成员有非常多的IT精英，比如：维基百科创始人阿桑奇，BT下载的作者布拉姆科恩，万维网发明者蒂姆.伯纳斯.李，Facebook创始人之一肖恩帕克等）。但中本聪本人一直没有出现在公众视野。</p>
<p> 历史上也出现过很多位“中本聪”：</p>
<ul>
<li>2012年5月，计算机科学家泰德·尼尔森在YouTube上曝料化名中本聪是京都大学的数学教授望月新一，但是这个说法始终没有被认证。</li>
<li>2014年黑客黑进中本聪使用过的邮箱，然后找到了邮件的主人：多利安.中本；但是中本表示只是偶然发现了邮箱的用户名和密码，并不是中本聪本人</li>
<li>2016年5月，澳大利亚企业家克雷格·史蒂芬·赖特通过媒体宣布，自己就是比特币创始人中本聪，之后赖特宣布放弃证明自己是中本聪。</li>
</ul>
<p>到现在，中本聪到底是谁，大家还是不知道，只知道他坐拥百万枚比特币，还获得了诺贝尔经济学奖提名，被誉为世界上最神秘的人。</p>
<h4 id="区块链如何去中心化"><a href="#区块链如何去中心化" class="headerlink" title="区块链如何去中心化"></a>区块链如何去中心化</h4><p>什么是中心化？<br>中心化的特点是中心掌握分布节点的信息，分布节点之间不掌握其他节点的信息。如图：<br><img src="/img/block/center_1.png" alt="这里写图片描述"></p>
<p>目前的基本所有机构，都可以认为是一个“中心化”的机构，例如：我们使用的聊天工具——微信，那么中心节点就是腾讯公司，分布节点就相当于我们用户，我们的各种信息，都存在腾讯公司的数据库中，腾讯公司想要修改我们的信息，窃听我们的消息，是非常容易的，因为腾讯公司就是“中心”，我们微信上使用的一切，都要依赖于腾讯公司这个中心。依次类推，我们的银行系统（央行是中心），我们的货币系统（央行是中心），国家机构（中央政府是中心）。这就是“中心化”。</p>
<p>区块链是如何去中心化的呢？<br>区块链可以理解为是一个去中心化的分布式数据库。这个数据库不依赖任何机构和管理员，区块链的作用就是存储信息，数据库的数据由全网的节点共同维护，任何人都可以接入区块链网络，成为一个数据节点。如果向数据节点写入数据，这个节点会将写入的数据信息广播到相邻的节点，然后相邻的节点再广播到它们相邻的节点，最终会将信息广播给全网的所有节点，最后所有的节点会同步数据，保证一致性。</p>
<p><img src="/img/block/center_2.png" alt="这里写图片描述"></p>
<p>通俗的讲，就是将原来只有中心节点才有的数据，现在给它弄到全网中都有，不再依赖一个中心的公司或者机构，而是依赖全网络，哪怕修改了数据被篡改了一个或者多个节点，也没关系，区块链系统中实现了共识算法，简单来说，就是保证少数服从多数，最后以大多数节点的信息作为真正的信息，由于网络里有无数节点，目前没有哪个公司或者机构可以同时操控这些节点一起篡改数据。<br>假如用区块链制作的微博或者微信会怎样呢？所有发布的消息，将无法受其他人修改或者删除，也就是说，你发布了某某某XXXX的消息，微博公司将再也无法将其删除或修改。</p>
<h3 id="比特币的原理和运转机制"><a href="#比特币的原理和运转机制" class="headerlink" title="比特币的原理和运转机制"></a>比特币的原理和运转机制</h3><p>首先，对比特币有一个整体的了解，比特币实际上可以理解为一个文件，确切的说可以理解为一个账本。这个账本基本上长这个样：</p>
<p><img src="/img/block/bitcron_transaction.png" alt="这里写图片描述"></p>
<p>这个账本中“from” 和 “to” 代表的是不同的比特币地址，可以理解为比特币账户，在比特币世界中，是没有账户余额概念的，只有一笔笔的从一个账户转到另外账户的转账信息。每当发起一比交易的时候，比特币系统会先通过你的比特币地址查到你之前的所有交易记录，看你是否有足够的钱去支付这笔交易。</p>
<p>这个账本不同于私人账本或者是银行的账本，它是一个全网都有的账本，不归属于某个人，而且全网都一样，每个网络节点人手一份，而且都是相同的。</p>
<p>当某个人A想要向B转账5个比特币，A会在比特币网络中广播这个消息，收到消息的节点一边将账本的副本信息更新，一边将这个消息继续广播，直到全网所有节点都收到。</p>
<p>如何来判断这个A转账到B5个比特币的消息是正确的呢？<br>针对每一笔交易，除了有转账信息，还会有一个数字签名，这个数字签名是有比特币地址账号唯一的私钥将转账消息的数字摘要加密创建生成的，每个网络节点拿着A的公钥对数字签名进行解密验证，就可以判断消息的准确性。<br>如果把转账信息比作是一份合同，那这个数字签名，你就可以理解为是类似于合同上一个亲笔签名的东西，来确保消息的准确性。</p>
<p>比特币系统中，每时每刻都会有无数多的交易在发生，比特币系统将这些交易信息按组分配，每个组称之为一个<code>区块</code>(block)，然后将这些区块按照时间顺序用链表一个一个的串起来，称之为<code>区块链</code>(the block chain)。区块链中的每个区块会引用前一个区块，你可以反向追踪至第一个区块中的交易信息。未在区块链中的信息是“未交易”或者未排序的信息，任何节点都有能力将一组未经确定的交易打包进区块，然后将它打包进区块的事实广播出去。<br>比特币系统显然不会让所有节点都参打包区块，这样非乱死不可，比特币系统会以每十分钟为一个周期，出一道计算题，这个计算题超级难，让全网的节点参与计算，这道计算题其实就是对当前区块的全部内容做一个特殊计算，得到一个哈希值，全网的所有网络节点通过比拼计算速度，强行匹配出哈希的值，最先计算出哈希值的节点将取得打包区块的权利，生成一个新的块<code>block</code>并连入现有的区块链，然后广播至所有其他节点，其他节点开始同步更新；最先计算出结果的节点除了拥有“记账”的权利，还可以获得一定量的比特币，这其实就是比特币的发行过程。参与打包区块的过程其实就是“挖矿”，参与“挖矿”的节点就是“矿工”。<br>哪怕计算题超级难，也有可能同一时刻两个网络节点同时算出值来，假如真有两个节点同时算出值来，该怎么办呢？<br>系统会同时让两个节点都记账，这样一来，区块链就会产生“分叉”，如何解决分叉呢？等到下一个区块产生后，看下一个区块连接到了哪个“分叉点”，然后系统会选择最长的链条，并把分叉去除，原来打包的区块将消失，区块中的交易信息将会重新回到“未确定的交易”信息池中。过程如下图：</p>
<p>下图是一个区块链</p>
<p><img src="/img/block/block_chain.png" alt="这里写图片描述"></p>
<p>过十分钟后，有两个“矿工”同时解决了问题，并同时产生了两个区块，于是区块链分叉了。</p>
<p><img src="/img/block/fencha_block_chain.png" alt="这里写图片描述"></p>
<p>分叉就分叉吧，没关系，全网节点同步区块链信息，将分叉的区块链同步到了各自的节点上。接着又过了十分钟，系统又出了一个题，一个矿工解答出了问题，注意，根据系统设计，连续两次节点同时解出问题的概率已经很小了，几乎不能可能。哪怕真有，也没关系，继续进行，最终只保留链路最长的。</p>
<p><img src="/img/block/fencha_1_block_chain.png" alt="这里写图片描述"></p>
<p>这是我们将放弃最短的路线，留下最长的链路</p>
<p><img src="/img/block/fencha_block_chain_final.png" alt="这里写图片描述"></p>
<p>比特币是如何保持总量恒定的呢？</p>
<p>随着越来越多的计算机加入比特币网络，“矿工”的计算能力会越来越强，为了让“矿工”恒定在每十分钟打包一个区块发行一次比特币，中本聪设计矿工挖矿的难度每过2016个区块动态提高一次，使得调整后的难度保持在十分钟。<br>每个比特币可以细分到小数点后八位，也就是说可以拿着0.00000001个比特币来交易。<br>刚开始每打包一个区块发行50个比特币，每21万个区块后，打包一个区块发行的比特币减半，比特币系统规定每十分钟打包一个区块，这样打包21万个区块需要四年的时间，直至2140年，比特币将无法细分，比特币发行完毕，发行总量约为2100万枚。</p>
<h3 id="比特币和区块链的关系"><a href="#比特币和区块链的关系" class="headerlink" title="比特币和区块链的关系"></a>比特币和区块链的关系</h3><p>比特币是区块链技术的应用，区块链是比特币的底层实现。可以说比特币是区块链技术的第一款应用。<br>区块链技术有去中心化、匿名性、公开透明的特点，现在市场上利用区块链技术做了非常多的应用：各种电子货币、百度莱茨狗、360区块猫。但是被人熟知的不算多。</p>
<h3 id="请关注我"><a href="#请关注我" class="headerlink" title="请关注我"></a>请关注我</h3><p>更多精彩内容，请搜索我的微信公众号 <code>码农RyuGou</code></p>
<p>或者扫码<img src="/img/weichat/qrcode.jpg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/08/bitcoin-and-blockchain/" data-id="clzo46btb000pvajh4h1e6ece" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Blockchain/" rel="tag">Blockchain</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Blockchain/" rel="tag">Blockchain</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">Go设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web%E5%8D%8F%E8%AE%AE/" rel="tag">web协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" rel="tag">字符集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Blockchain/" style="font-size: 10px;">Blockchain</a> <a href="/tags/Golang/" style="font-size: 16.67px;">Golang</a> <a href="/tags/Go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.33px;">Go设计模式</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/mysql/" style="font-size: 11.67px;">mysql</a> <a href="/tags/php/" style="font-size: 18.33px;">php</a> <a href="/tags/web%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">web协议</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 15px;">其他</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/" style="font-size: 10px;">字符集</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 11.67px;">计算机基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/12/16/singleton/">Go语言设计模式之单例模式</a>
          </li>
        
          <li>
            <a href="/2023/10/21/decorator/">Go语言设计模式之装饰模式</a>
          </li>
        
          <li>
            <a href="/2023/07/29/pattern-linked/">Go语言设计模式之责任链模式</a>
          </li>
        
          <li>
            <a href="/2022/10/16/http2/">http2.0 一篇就够了</a>
          </li>
        
          <li>
            <a href="/2022/03/19/js-learning-1/">JS的那些坑（一）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 菜刚<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>